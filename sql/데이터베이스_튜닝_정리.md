## 파티션 인덱스
![](../assets/sql/%ED%8C%8C%ED%8B%B0%EC%85%98%EC%9D%B8%EB%8D%B1%EC%8A%A4.png)
![](../assets/sql/%ED%8C%8C%ED%8B%B0%EC%85%98%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%A0%95%EB%A6%AC.PNG)

## 증분 쿼리
```
1) OUTER JOIN방식
SELECT A.*
FROM A, B
WHERE A.KEY = B.KEY(+)
AND B.KEY IS NULL;

2) NOT IN (대용량에 부적합)
SELECT A.* 
FROM A, B
WHERE A.KEY = B.KEY(+)
AND NVL(B.STATUS, 'W') NOT IN ('S','F');

3) NOT EXISTS
SELECT *
FROM A
WHERE NOT EXISTS (SELECT *
                    FROM B
                    WHERE A.KEY = B.KEY);

튜닝 원칙
- 데이터 제한 조건은 인덱스를 사용
- 데이터 불러오는 양을 적게할수록 좋음
- 사용자 함수는 자제 ---> http://www.gurubee.net/article/14081 사용자 함수의 튜닝방법
- FULLTABLESCAN이 나쁜것만은 아니다(왜?)
- NOT IN 보다는 IN 사용 권장
- NOT EXISTS 보다는 EXISTS 사용 권장
- UNION 보다는 UNION ALL 사용 권장 
```

## 랜덤 액세스 종류
- 확인 랜덤 액세스: WHERE 조건의 컬럼이 인덱스에 존재하지 않아 테이블을 액세스 
- 추출 랜덤 액세스: SELECT 절의 컬럼이 인덱스에 없어 테이블을 액세스
- 정렬 랜덤 액세스: ORDER BY 절 등에 사용된 컬럼이 인덱스에 존재하지 않아 테이블을 액세스하여 정렬을 수행하기 위해 데이터를 액세스 
- 확인 랜덤 액세스가 랜덤 액세스 중 가장 많을 부하를 발생시키며 이를 최우선적으로 제거하기 위해 노력해야 한다. 


## 스칼라 서브쿼리 캐싱 효과
- 오라클은 스칼라 서브쿼리의 입력 값과 출력 값을 내부 캐시(QUERY EXECUTION CACHE)에 저장
- 스칼라 서브쿼리가 수행될 때 일단 입력 값을 캐시에서 찾아보고 있으면 저장된 출력 값을 리턴
- 캐시에서 찾지 못할 경우 쿼리 수행, 결과 값은 캐시에 저장
```
-- 반복수행되는 함수 때문에 쿼리 성능이 크게 저하될 경우 스칼라 서브쿼리를 이용하여 튜닝
-- 그냥 함수 호출 -> 캐싱X VS 서브쿼리로 호출 -> 캐싱O 
SELECT EMPNO, ENAME, SAL, HIREDATE
    , (SELECT GET_DATE(DEPTNO) FROM DUAL) DNAME
FROM EMP E
WHERE SAL >= 2000;
```
- 스칼라 서브쿼리의 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 적을 때 큼
- 입력 값의 종류가 많으면 캐시를 확인하는 비용 때문에 오히려 성능은 저하되고 CPU 사용률만 높아짐 -------> 입력 값이 많으면 캐시에 없을 확률이 높아지고, 그냥 쿼리를 실행시키면 될 걸 굳이 캐시를 뒤지는 시간까지 포함이 되어 쿼리를 수행하기 때문에 효율이 저하된다.

## PARALLEL 힌트 우선순위
```
SELECT /*+ PARALLEL(24) */ *
  FROM TABLE A  -----> 24개 프로세스 병렬수행

SELECT /*+ PARALLEL(24) */ *
  FROM TABLE A, TABLE B  
  WHERE A.COL1 = B.COL1 -----> 48개 프로세스 병렬수행

SELECT /*+ PARALLEL(24) */ *
 FROM TABLE A
    , (SELECT /*+PARALLEL(48)*/ *
         FROM TABLE B)
 WHERE A.COL1 = B.COL1 ------> 24개 프로세스 병렬수행(메인쿼리 설정을 따라감)
```

## 힌트가 무시되는 경우 
1. 문법적으로 맞지 않게 힌트를 기술
2. 잘못된 참조 사용: 없는 테이블 별칭을 사용한 경우, 없는 인덱스 명을 지정한 경우 등 
3. 논리적으로 불가능한 엑세스 경로 
    - 조인절에 등치 조건이 하나도 없는데 해시 조인으로 유도
    - 테이블 전체 건수를 COUNT하는 쿼리에 NULL을 허용하는 단일 컬럼으로 생성한 인덱스를 사용하도록 힌트를 기술한 경우
4. 의미적으로 맞지 않게 기술: 예를 들어, 서브쿼리에 UNNEST와 PUSH_SUBQ를 같이 기술한 경우
5. <U>옵티마이저에 의해 내부적으로 쿼리가 변환된 경우</U>
6. 버그 

## 힌트 조인순서 
```
SELECT /*+ LEADING(C A D B) USE_NL(A) USE_NL(D) USE_HASH(B) */
=> C,A,D,B 순으로 A와 D를 조인할 때는 NL조인으로, B와 조인할 때는 HASH조인으로
SELECT /*+ USE_NL(A B C D) */ 
=> A,B,C,D를 조인할 때 모두 NL조인으로 하고, 조인순서는 옵티마이저에게 맡김
```

## 바인드 변수와 실행계획 
-> 바인드 변수를 사용하면 통계 정보를 제대로 이요하지 못해 악성 실행 계획을 수립하는 경우가 발생한다. 나 같은 경우 INSERT-SELECT 쿼리를 직접 서버에 날리면 문제가 없는데, 바인드 변수를 받는 SP를 사용할 때 급격하게 느려지는 경우가 있었다. SP 내에서 바인드 변수 대신 리터럴 변수를 사용하거나, 힌트를 정확히 명시했을 때 해결되는 것을 보면 옵티마이저가 악성 실행 계획을 세운 것이라 추측이 된다. 
http://wiki.gurubee.net/pages/viewpage.action?pageId=26741319