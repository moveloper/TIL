```js

// 1. 템플릿 리터럴 
let name = "moveloper"
let name2 = `My name is ${name}`
 
// 2. null병합 연산자: 왼쪽 피연산자가 null 또는 undefined일 때 오른쪽 피연산자를 반환하고, 그렇지 
// 않으면 왼쪽 피연산자를 반환 
let a; // a: undefined 
a = a ?? 10;
console.log(a); // 10
let b = null;
console.log(b ?? 10) // 10

// 3. 함수도 데이터타입이기 때문에 변수와 상수에 담아서 사용가능. 변수 이름이 함수 이름
// 기존 방식 = 함수 선언식, 아래는 함수 표현식 
// 차이점: 함수 선언식은 호이스팅으로 함수가 선언된 곳보다 위에서 사용가능 
//        함수 표현식은 호이스팅 대상이 아니라 담긴 변수나 상수가 초기화 된 이후 사용가능

console.log(helloA()); // 에러
console.log(helloB()); // helloB

let helloA = function() { // 함수 표현식
  return "helloA"
};

function helloB() { // 함수 선언식
  return "helloB:"
}

const helloText = helloA();
console.log(helloText); // helloA

// 4. 화살표 함수(호이스팅 대상X) 
let hello = () => "hello"

// 5. 콜백 함수: 함수의 매개변수에 함수를 사용하는 것 

// 일반 함수로 사용하면 기분에 따른 행동을 동적으로 줄 수 없다. 
function checkMood (mood) {
  if (mood === 'good') {
    sing()
  } else {
    cry()
  }
}

function sing() {console.log("SING");}
function dance() {console.log("DANCE");}
function cry() {console.log("CRY");} 
checkMood('good');

// 콜백함수로 사용하면 기분에 따른 행동을 동적으로 줄 수 있다. 유연함
function checkMood (mood, goodCallback, badCallback) {
  if (mood === 'good') {
    goodCallback()
  } else {
    badCallback()
  }
}

function sing() {console.log("SING");}
function dance() {console.log("DANCE");}
function cry() {console.log("CRY");} 

checkMood('good', sing, cry);

// 6. 객체
let person1 = new Object(); // 생성자 방식
let person2 = {}; // 객체 리터럴 방식(선호)
let person3 = {
  key1: "value1", // 프로퍼티(객체 프로퍼티). 키는 문자열, 값은 모든 자료형 가능. 중복된 키는 가장 뒤에 있는 프로퍼티 사용.
  key2: 123,  
  key3: true,
  key4: undefined,
  key5: function() {
        console.log(`key1의 값은 ${this["key1"]}`); // this를 person3으로 바꿔도 됨
      } // 메서드로 부름. 나머지는 멤버
  }
// 프로퍼티 값 사용하는 2가지 방법
console.log(person3.key1);
console.log(person3["key2"]); // [] 안에 반드시 문자열로 사용. 동적 파라미터로 받을 때 유용
function getPropertyValue(key) {
  return person3[key];
}
console.log(getPropertyValue("key4"));

// 함수 호출
person3.key5(); 
person3["key5"](); 


// 상수로 선언한 객체의 프로퍼티를 바꿔도 오류발생x 
person3.["key2"] = 40; // ok 
// 대신 상수가 참고하고있는 객체 자체를 바꾸면 오류발생o
person3 = { newKey: 1, ...} // error

// 프로퍼티 제거
delete person3["key5"]; // 메모리에서는 지워지지 않음
person3.key5 = null; // 메모리에서도 지워짐. 추천

// 프로퍼티 존재 여부 확인 
console.log(`key1: ${"key1" in person3}`);

```
