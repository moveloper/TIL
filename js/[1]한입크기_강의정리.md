```js

// 1. 템플릿 리터럴 
let name = "moveloper"
let name2 = `My name is ${name}`
 
// 2. null병합 연산자: 왼쪽 피연산자가 null 또는 undefined일 때 오른쪽 피연산자를 반환하고, 그렇지 
// 않으면 왼쪽 피연산자를 반환 
let a; // a: undefined 
a = a ?? 10;
console.log(a); // 10
let b = null;
console.log(b ?? 10) // 10

// 3. 함수도 데이터타입이기 때문에 변수와 상수에 담아서 사용가능. 변수 이름이 함수 이름
// 기존 방식 = 함수 선언식, 아래는 함수 표현식 
// 차이점: 함수 선언식은 호이스팅으로 함수가 선언된 곳보다 위에서 사용가능 
//        함수 표현식은 호이스팅 대상이 아니라 담긴 변수나 상수가 초기화 된 이후 사용가능

console.log(helloA()); // 에러
console.log(helloB()); // helloB

let helloA = function() { // 함수 표현식
  return "helloA"
};

function helloB() { // 함수 선언식
  return "helloB:"
}

const helloText = helloA();
console.log(helloText); // helloA

// 4. 화살표 함수(호이스팅 대상X) 
let hello = () => "hello"

// 5. 콜백 함수: 함수의 매개변수에 함수를 사용하는 것 

// 일반 함수로 사용하면 기분에 따른 행동을 동적으로 줄 수 없다. 
function checkMood (mood) {
  if (mood === 'good') {
    sing()
  } else {
    cry()
  }
}

function sing() {console.log("SING");}
function dance() {console.log("DANCE");}
function cry() {console.log("CRY");} 
checkMood('good');

// 콜백함수로 사용하면 기분에 따른 행동을 동적으로 줄 수 있다. 유연함
function checkMood (mood, goodCallback, badCallback) {
  if (mood === 'good') {
    goodCallback()
  } else {
    badCallback()
  }
}

function sing() {console.log("SING");}
function dance() {console.log("DANCE");}
function cry() {console.log("CRY");} 

checkMood('good', sing, cry);

// 6. 객체
let person1 = new Object(); // 생성자 방식
let person2 = {}; // 객체 리터럴 방식(선호)
let person3 = {
  key1: "value1", // 프로퍼티(객체 프로퍼티). 키는 문자열, 값은 모든 자료형 가능. 중복된 키는 가장 뒤에 있는 프로퍼티 사용.
  key2: 123,  
  key3: true,
  key4: undefined,
  key5: function() {
        console.log(`key1의 값은 ${this["key1"]}`); // this를 person3으로 바꿔도 됨
      } // 메서드로 부름. 나머지는 멤버
  }
// 프로퍼티 값 사용하는 2가지 방법
console.log(person3.key1);
console.log(person3["key2"]); // [] 안에 반드시 문자열로 사용. 동적 파라미터로 받을 때 유용
function getPropertyValue(key) {
  return person3[key];
}
console.log(getPropertyValue("key4"));

// 함수 호출
person3.key5(); 
person3["key5"](); 


// 상수로 선언한 객체의 프로퍼티를 바꿔도 오류발생x 
person3.["key2"] = 40; // ok 
// 대신 상수가 참고하고있는 객체 자체를 바꾸면 오류발생o
person3 = { newKey: 1, ...} // error

// 프로퍼티 제거
delete person3["key5"]; // 메모리에서는 지워지지 않음
person3.key5 = null; // 메모리에서도 지워짐. 추천

// 프로퍼티 존재 여부 확인 
console.log(`key1: ${"key1" in person3}`);

// 7. 배열
let arr = new Array();
let arr = [1, "2", true, null, undefined, {}, [], function(){}]; // 배열 리터럴 

arr.push({key: "value"});

// 8. 반복문 
let person = {
  name: "kim",
  age: 30,
  tall: 180
}

const personKeys = Object.keys(person); 
const personValues = Object.values(person);
console.log(personKeys); // ["name", "age", "tall"]

for(let i = 0; i < personKeys.length; i++) {
  const curKey = personKeys[i];
  const curValue = person[curKey];
}

// 9. 배열 내장함수 
const arr = {1, 2, 3, 4};
// 1)
arr.forEach((elm) => console.log(elm));
// 2)
const newArr = arr.map((elm) => {
  return elm * 2;
});
// 3)
arr.includes(3); // === 연산의 결과(타입까지 같아야됨)
// 4)
arr.indexOf(3); // 일치하는 값 없으면 -1 리턴.
// 5)
const arr = [{num: 1, color: "green"}, {num: 2, color: "black"}, {num: 3, color: "green"}];
arr.findIndex((elm)=>{ 
  return elm.color === "green"
}); // 조건을 만족하는 첫번째 인덱스 반환: 0

const element = arr.find((elm) => elm.color === "green"}); // 조건을 만족하는 첫번째 요소 반환 {color: "green"}

console.log(arr.filter((elm)=>{elm.color==="black""}));
// 6)
console.log(arr.slice(0,2)); // 0, 1번 인덱스까지 배열을 자른 배열 반환 
console.log(arr1.concat(arr2)); // 합쳐진 하나의 배열 반환 
// 7)
let chars = ["나", "다", "가"];
chars.sort(); // 문자열 기준 정리 
let numbers = [0, 1, 3, 2, 10, 30, 20];
numbers.sort(); // [0, 1, ,10, 2, 20, 3, 30];

const compare = (a, b) => {
  if (a > b) {
    return 1;
  }
  if (a < b) {
    return -1;
  }
  return 0;
}
number.sort(compare); // [0, 1, 2, 3, 10, 20, 30]
// 8)
const arr = ["안녕하세요", "홍길동님", "반갑습니다", "."];
arr.join(); // 안녕하세요,홍길동님,반갑습니다,.
arr.join(" "); // 안녕하세요 홍길동님 반갑습니다 . 

```


```


```