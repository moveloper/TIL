# 자바문법 찾아보기 

[2차원 배열 정렬 방법](https://gre-eny.tistory.com/m/2) : 추가로 보면 좋은 객체 배열 정렬하기 => https://codevang.tistory.com/288 => Arrays.sort 함수에서 사용되는 Comparable, Comparator의 compareTo, compare 함수의 파라미터로 들어오는 기준값이 직관적으로 생각하는 것의 반대이기 때문에 음수일 경우 두 요소의 위치를 바꾸고, 양수일 경우 두 요소의 위치를 그대로 두는 것이 맞다. 하지만 직관적으로 순서대로 파라미터를 비교한다고 생각해보자(역). 두 수의 차가 음수이면 위치를 그대로 두고, 양수이면 바꾼다고 생각(역)하면 역의 역이 되기 때문에 참이 된다. 직관적으로 이해해도 문제는 없지만, 비교함수의 리턴을 -1, 1로 사용할 때 원하는 결과의 반대의 결과를 얻을 수 있으니 조심하자. 

[Comparable과 Comparator의 이해](https://st-lab.tistory.com/243)

[Comparator 인터페이스에는 왜 추상메소드가 2개일까?](https://mkyong.com/java8/is-comparator-a-function-interface-but-it-has-two-abstract-methods/) :
함수형 인터페이스는 한 개의 추상메소드만 가질 수 있는데, Comparator 함수형 인터페이스는 추상메소드가 2개라 발생한 의문점

[특정 문자를 가지고 문자열 나누기(정규표현식 문자일 떈?)](https://kudolove.tistory.com/m/275)

[제네릭의 이해](https://st-lab.tistory.com/153)
 
[람다식의 타입과 multiple bounds를 활용한 형변환](#람다식의-타입과-형변환)  
 


## 람다식의 타입과 형변환 

함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. 람다식은 익명 객체이고, 익명 객체는 타입이 없다. 정확히는 타입이 있지만 컴파일러가 임의의 이름을 정하기 때문에 알 수 없는 것이다. 그래서 대입 연산자의 양변의 타입을 일치시키기 위해 아래와 같이 형변환이 필요하다.

```java
MyFunction f = (MyFunction) (() -> {}); // 양변의 타입이 다르기때문에 형변환이 필요, 형변환 생략가능
```

람다식은 Object타입으로 형변환은 할 수없다. 그럼에도 Object타입으로 형변환을 하려면 함수형 인터페이스로 형변환을 먼저 해야한다.

```java 
Object obj = (Object) (() -> {}); // Error, 함수형 인터페이스만 형변환 가능
Object obj = (Object) (MyFunction) (() -> {}); // 함수형 인터페이스로 먼저 형변환, Object타입으로 다시 형변환
String str = ((Object) (MyFunction) (() -> {})).toString();
```

### (class & interface) 형변환 표현
https://docs.oracle.com/javase/tutorial/java/generics/bounded.html  
https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.16 

자바 8이후에 Multiple Bounds가 가능하다. 

### multiple bounds를 활용한 람다직렬화
https://stackoverflow.com/questions/22807912/how-to-serialize-a-lambda

```java 
Runnable r = (Runnable & Serializable)() -> System.out.println("Serializable!");

// Note: this only works if you apply the cast during construction. The following will throw a ClassCastException: 
Runnable r = () -> System.out.println("Serializable!"); 
Runnable serializableR = (Runnable & Serializable) r;
```

익명 클래스보다는 람다를 사용하라(맨 아래쪽 람다와 직렬화) https://javabom.tistory.com/66 
람다를 직렬화하지 말라는데 이유는 뭘까? https://techblog.woowahan.com/2551/