# 컴퓨터 구조

## 10진법
각 자리가 0~9까지 10가지 숫자 + 각 자리는 10의 제곱을 뜻한다  
* 3413 = 3*10^3 + 4*10^2 + 1*10^1 + 3*10^0 : 천의 자리 3과 일의 자리 3은 같은 3이 아니다

## 2진법 

각 자리가 0과 1 두 가지 숫자 + 각 자리는 2의 제곱을 뜻한다  
* 1011(2) = 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 11(10)  
* 2진수의 음수 표현법 => 부호비트와 보수법을 이용
* 최상위 비트(MSB: Most Significant Bit)를 부호비트로 사용  
    0 (양수) 0 0 0 0 0 0 0 = 0   
    0 (양수) 1 1 1 1 1 1 1 = 127  
    1 (음수) 0 0 0 0 0 0 0 = -128  
    1 (음수) 1 1 1 1 1 1 1 = -1   

## 보수법

컴퓨터에서는 덧셈과 보수의 개념을 사용하여 뺄셈을 처리한다. n에 대한 m의 보수는 n - m을 의미한다.   
ex) 10에 대한 6의 보수는 4를 이용: 12 - 6 = 2 + (10 - 6) = 2 + (10에 대한 6의 보수 4)  

* r진법에서 r의 보수: 10진법에서 10의 보수, 2진법에서 2의 보수
* r진법에서 r-1의 보수: 10진법에서 9의 보수, 2진법에서 1의 보수

2진법에서 1의 보수는 1과0의 숫자를 뒤집기만 하면 되니 유용하다
* 십진수 3000의 10의 보수는 7000 (자리올림 발생)
* 십진수 12345의 9의 보수는 87654 
* 이진수 0111의 1의 보수는 1000(2)
* 이진수 0111 의 2의 보수는 ??  두 수를 더하여 자리올림이 발생하는 값
* 0111(2) + ? = 10000(2) //   ? = 1001(2)  
* 2의 보수 = 1의 보수 + 1

<u>1의 보수가 아닌 2의 보수를 사용하는 이유는 
1의 보수에선 0이 2개 생기기 때문에(0과 -0) 1비트 차이가 나게 되기 때문이다.</u>                                                        



## 오버플로우 및 언더플로우

컴퓨터의 수체계로 인해 언더 및 오버 플로우가 발생 

ex) 130(10) 을 byte 자료형에 넣으면 1 0 0 0 0 0 0 1 0 을 -126으로 인식  => 오버플로우 발생 
  
>127에 1을 더하게 되면
01111111[127] + 1 = 10000000[-128]
-128에 1을 빼게 되면
10000000[-128] - 1 = 01111111[127]

즉 범위를 벗어나면 최댓값과 최솟값이 연결되어 진행된다. 

---

## 컴퓨터는 결국 전기로 작동하는 기계
원자 → 전자 → 반도체 → 트랜지스터 → 집적회로(IC)  
논리회로 소자(논리 게이트)를 이용해 각종 회로를 만든다. 

## 디지털 논리회로 = 조합 논리회로 vs 순차 논리회로
조합 논리회로는 출력신호가 입력신호에 의해서만 결정되며, 기본 논리소자의 조합으로 만들어지고 플립플롭과 같은 기억소자는 포함하지 않는다. 조합 논리회로의 종류로는 가산기, 비교기, 디코더와 인코더, 멀티플렉서와 디멀티플렉서, 코드변환기 등이 있다. 이와 반대로 순차 논리회로는 출력신호가 입력신호뿐만 아닌 이전 상태의 논리값에 의해 결정되는 회로이며, 비트 값을 저장하는 플립플롭과 같은 기억소자를 포함한다. 

## 래치 
래치는 수동적 또는 전자적 조작으로 상태를 바꾸지 않는 한 그 상태를 유지해주는 장치 또는 회로를 말한다. 따라서 래치는 주어진 상태를 유지 보관할 수 있도록 NAND 게이트 또는 NOR 게이트를 이용하여 회로를 구성한다. 논리회로로 구성되었기 때문에 논리회로에 준하는 빠른 속도로 동작한다. 그리고 이 래치는 플립플롭으로 활용한다.

## 플립플롭
1비트의 정보를 기억할 수 있는 회로로 컴퓨터의 주기억장치 RAM이나 캐시기억장치, 레지스터를 구성하는 기본 회로다. 입력에 따른 출력 하나가 지연되면, 이를 다시 입력에 궤한하는 것으로 정보를 기억한다. 플립플롭은 전원이 있을 때만 정보가 기억 유지되며 전원이 차단되면 정보가 사라지는 휘발성 기억소자이다. 

## 클록 펄스
클록 펄스(Clock pulse)란 컴퓨터 등의 디지털 시스템에서 동일한 시스템 내에서 동작하는 각 구성 요소의 모든 동작을 동기화(Synchronize)하기 위해 사용하는 전자적인 펄스를 말한다. 클록 펄스는 수정 발진자(Crystal oscillator)의 규칙적인 진동에 의해 발생하는 일정한 간격을 갖는 전자적인 펄스인데 컴퓨터의 시스템 클록(CPU 클록)은 이 펄스를 타이밍 펄스 또는 디지털 신호로 사용해 시스템 내의 각 장치와 회로의 모든 동작을 동기화한다. 클록 펄스의 발생 주기(Cycle)를 클록 속도 또는 클록 주파수라고 한다. 

## 레지스터와 램의 차이
플립플롭으로 만들어진 레지스터는 플립플롭 여러 개를 일렬로 배열하고 적당히 연결해 여러 비트로 구성된 2진수를 일시적으로 저장하거나 저장된 비트를 좌측 또는 우측으로 하나씩 이동할 때 사용한다. 

RAM은 일반적으로 컴퓨터의 주기억 장치로 사용하며 인스트럭션을 로드하여 저장하는 장치로 주로 사용한다.

흔히 RAM이라고 하는 이 메모리는 Dynamic RAM 이라고 하는 DRAM으로 이루어져 있으며, DRAM과 대조되는 특성을 지니고 있는 소자가 바로 플립플롭으로 구성된 Static RAM, 줄여서 SRAM이다. DRAM은 MOS 트랜지스터 안에 있는 콘덴서에 전하의 형태로 저장이 되며 이 전하는 시간이 흐름에 따라 방전되는 특성이 있으므로 주기적으로 재충전해줘야 한다. 결국 이런 DRAM은 1비트당 하나의 트랜지스터 소자로 이루어져 있다.

반면 SRAM은 플립플롭소자로 구성되어 있으며 이는 전원이 연결되어 있는 동안에는 내용을 계속 유지하며, Read/Write시간이 DRAM에 비해 무척 빠르다는 특성이 있다 대신 한 비트당 보통 4~6개의 트랜지스터로 이루어져 있어서 가격이 DRAM보다 비싸다

<u>레지스터 역시 이러한 RAM의 일종이긴 하지만 흔히 메모리라고 하면 연상되는 주기억장치인 램과 구분되는 점은 물리적인 구성의 차이가 아니라 그 사용 용도에 따른 것이다.</u>
레지스터는 CPU칩 내부에 존재하며 직접적으로 ALU에 연결되어 입출력 값을 저장하는 역할을 한다. 반면 RAM은 일반적으로 CPU와 별도로 어드레스 라인과 데이터 라인으로 연결되어있으며 CPU에서 어드레스 라인으로 주소를 지정하여 해당 주소의 데이터를 읽고 쓰는 방식이다.

한편 CPU의 속도를 좌우하는 클럭 주기에 가장 큰 영향을 미치는 부분 중 하나가 레지스터의 속도이다. 레지스터는 일반적으로 주기억장치처럼 대용량을 필요로 하지 않는다. 따라서 이러한 특성을 고려하여 일반적으로 레지스터는 SRAM으로 구성하게 된다. 따라서 메모리의 한 종류일 뿐이지만 그 사용용도가 CPU 내부에 국한 되어 있고 직접적으로 인스트럭션의 구성에 영향을 미치므로 특별히 레지스터라고 부른다.

※캐쉬 역시 빠른속도를 요하고 주 기억 장치보다 소용량인 점을 감안해 SRAM으로 구성하는것이 일반적이다.

## 카운터 
클록 펄스에 따라 수를 세는 계수 능력을 갖는 논리회로다. 데이터를 일시에 저장하거나, 전송하는 기능이 있는 플립플롭으로 구성되어 있는 카운트는 입력에 들어오는 펄스의 수를 계수해 컴퓨터가 여러 가지 동작을 수행하는 데 필요한 타이밍 신호를 제공한다. 

---

## 엔디안
메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법을 말하며, 바이트를 배열하는 방법을 특히 바이트 순서라고 한다. 인텔 프로세서 같은 기계에서는 0번 바이트가 가장 오른쪽으로 가는 리틀 엔디안을 사용하고 모토로라 프로세서 같은 기계에서는 0번 바이트가 가장 왼쪽에 간다. 한 시스템에서 다른 시스템으로 데이터를 전송할 때는 엔디안을 염두해 둬야 한다.

## 중앙 처리 장치(CPU)
* 산술 논리 장치(ALU)는 산술 계산, 불리언 대수 및 기타 연산을 수행한다. 
* 실행 장치(execution unit)는 제어 장치(control unit)라고도 알려져 있으며, 컴퓨터의 대장 역할을 한다. 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다. 이러한 수행을 위해 프로그램 카운터(PC)를 사용한다. 
* 프로그램의 어디에 있는지 추적할 수 있는 레지스터를 명령어 주소 레지스터(instruction address register, 주소 레지스터, 메모리 주소 레지스터)라고 하고 이름에서 알 수 있듯이 현재 instruction의 메모리 주소를 저장한다. 그리고 현재 수행되는 명령어가 저장되는 레지스터가 필요하다. 이 레지스터는 명령어 레지스터(instruction register)라고 한다. 
​![](/assets/cs/cpu추상화구조.PNG)
​![](/assets/cs/cpu추상화구조2.PNG)
cpu 작동원리 정리: https://www.youtube.com/watch?v=Fg00LN30Ezg

## 멀티프로세서 vs 멀티코어
1980년대에 처음 만들어진 멀티프로세서 시스템은 여러 CPU를 활용하여 성능을 높이는 방법이다. 여러 CPU를 활용할 수 있도록 프로그램을 병렬화하는 것이 중요하다. 멀티 코어는 단일 CPU를 사용하지만 프로그램의 명령을 읽고 수행하는 코어를 여러 개를 두어 사용하는 시스템이다. 

프로세스와 스레드 정리할 내용:
https://modoocode.com/269

## 인터럽트
CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다. 
 * 인터럽트 핸들러: 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 한다. 운영체제의 코드 영역에는 인터럽트별로 처리해야할 내용이 이미 프로그램되어 있다. 
 * 인터럽트 백터: 인터럽트 발생시 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고 있는 테이블이다. 
 * PCB(Process Control Block): 커널의 데이터 영역에 존재하며 각각의 프로세스마다 고유의 PCB가 있다. 인터럽트 발생시 프로세스의 어느 부분이 수행중이었는지를 저장한다.(수행중이던 메모리 주소, 레지스터값, 하드웨어 상태 등)

### 인터럽트 과정
1. process A는 system call을 통해 인터럽트를 발생시킨다.
2. CPU는 현재 진행 중인 기계어 코드를 완료한다.
3. 현재까지 수행중이었던 상태를 해당 process의 PCB(Process Control Block)에 저장한다. (수행중이던 MEMORY주소, 레지스터 값, 하드웨어 상태 등...)
4. PC(Program Counter, IP)에 다음에 실행할 명령의 주소를 저장한다.
인터럽트 벡터를 읽고 ISR 주소값을 얻어 ISR(Interrupt Service Routine)로 점프하여 루틴을 실행한다.
5. 해당 코드를 실행한다.
6. 해당 일을 다 처리하면, 대피시킨 레지스터를 복원한다.
7. ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제 된다.
8. IRET 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원한다.